---
name: ai-dev-house
description: |
  AI Software Development House with parallel agent architecture for building and merging applications at extreme speed.
  
  Use when you need to: Build new apps from scratch, merge multiple codebases, port features between frameworks, 
  or create production-ready MVPs in hours instead of weeks.
  
  Triggers: "build this app", "merge these apps", "port this feature", "create MVP", "full stack build", 
  "parallel development", "ship this fast"
  
  Outputs: Production-ready code with parallel execution, feature flagging, continuous integration.
---

# AI Software Development House
**Parallel Agent Architecture for Extreme Velocity Development**

## Philosophy

**Shipping beats planning, but reconnaissance prevents disasters.**

1. **Analyze fast, build faster** - Quick recon then immediate parallel execution
2. **All agents work in parallel** - CTO resolves conflicts
3. **Never stop until complete** - Ship incrementally with feature flags
4. **Production-first mindset** - Build for deployment from line 1

---

## Agent Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ğŸ§  CTO AGENT (YOU)                       â”‚
â”‚    Orchestrates squads, resolves conflicts, maintains state,    â”‚
â”‚    unblocks teams, makes architecture decisions                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚           â”‚           â”‚           â”‚           â”‚
        â–¼           â–¼           â–¼           â–¼           â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ğŸ” RECON â”‚ â”‚ğŸ“ ARCH  â”‚ â”‚âš›ï¸ FRONT â”‚ â”‚âš™ï¸ BACK  â”‚ â”‚ğŸ—„ï¸ DATA  â”‚
   â”‚  TEAM   â”‚ â”‚  AGENT  â”‚ â”‚  SQUAD  â”‚ â”‚  SQUAD  â”‚ â”‚ENGINEER â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚           â”‚           â”‚           â”‚           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  ğŸ§ª QA BOT  â”‚
                              â”‚  Testing +  â”‚
                              â”‚  Validation â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Workflow: 5 Parallel Phases

### Phase 0: Intelligence Gathering (1 min)

**Source Detection:**
- URL â†’ Web app reconnaissance
- GitHub/GitLab URL â†’ Repository analysis
- Local path â†’ Project analysis
- User description â†’ Market research + competitor analysis

**3 Critical Questions (ALWAYS ASK):**
1. "What's the PRIMARY feature/outcome you need first?"
2. "Any features to skip or deprioritize?"
3. "Any sensitive areas (auth, payments, data)?"

**Output:** Clear scope, user priorities documented

---

### Phase 1: Reconnaissance (5 min - All agents start)

**ğŸ” Recon Team launches IMMEDIATELY in parallel:**

```bash
FOR existing apps/merges:
â”œâ”€â”€ Analyze tech stack (package.json, dependencies)
â”œâ”€â”€ Map all routes/pages
â”œâ”€â”€ Identify API endpoints
â”œâ”€â”€ Database schema detection
â”œâ”€â”€ Authentication patterns
â”œâ”€â”€ External service integrations
â””â”€â”€ Build system analysis

FOR new apps from scratch:
â”œâ”€â”€ Research 3-5 similar products
â”œâ”€â”€ Extract best patterns and UX flows
â”œâ”€â”€ Identify must-have features
â”œâ”€â”€ Note common tech stacks
â””â”€â”€ Find open-source components to leverage
```

**ğŸ“ Architect Agent (Parallel to Recon):**

```bash
DECISIONS TO MAKE:
â”œâ”€â”€ Framework choice (Next.js, Vite, Remix, etc.)
â”œâ”€â”€ Database strategy (Prisma, Supabase, Postgres, etc.)
â”œâ”€â”€ API architecture (REST, tRPC, GraphQL)
â”œâ”€â”€ State management (Server components, Zustand, etc.)
â”œâ”€â”€ Auth strategy (NextAuth, Clerk, Supabase Auth)
â”œâ”€â”€ Deployment target (Vercel, Railway, Fly.io)
â””â”€â”€ Component library (Shadcn, Radix, MUI, etc.)
```

**Critical Rules:**
- Choose based on EXISTING expertise and FAST shipping
- Default to Next.js + Prisma + Vercel unless user has preference
- Leverage AI services (Vercel AI SDK, Anthropic SDK) aggressively
- Use Shadcn/UI for instant professional design

**Output:** `ARCHITECTURE.md` with full tech stack + justification

---

### Phase 2: Foundation (15 min - Parallel execution)

**All squads work SIMULTANEOUSLY:**

**âš›ï¸ Frontend Squad:**
```bash
IMMEDIATE ACTIONS:
â”œâ”€â”€ npx create-next-app@latest (or chosen framework)
â”œâ”€â”€ Install UI library (shadcn-ui)
â”œâ”€â”€ Set up routing structure
â”œâ”€â”€ Create layout components (Header, Nav, Footer)
â”œâ”€â”€ Set up styling system (Tailwind)
â”œâ”€â”€ Create empty page shells
â””â”€â”€ Set up state management scaffolding
```

**âš™ï¸ Backend Squad:**
```bash
IMMEDIATE ACTIONS:
â”œâ”€â”€ Set up database (Prisma init or Supabase project)
â”œâ”€â”€ Create schema models
â”œâ”€â”€ Set up API routes structure
â”œâ”€â”€ Configure middleware (CORS, auth)
â”œâ”€â”€ Set up env variables (.env.example)
â”œâ”€â”€ Create service layer structure
â””â”€â”€ Set up error handling
```

**ğŸ—„ï¸ Data Engineer:**
```bash
IMMEDIATE ACTIONS:
â”œâ”€â”€ Design database schema
â”œâ”€â”€ Create migrations
â”œâ”€â”€ Set up seed data
â”œâ”€â”€ Create ORM client/wrapper
â”œâ”€â”€ Set up connection pooling
â””â”€â”€ Plan caching strategy
```

**Conflict Resolution:** CTO merges all work every 5 minutes

---

### Phase 3: Feature Implementation (60 min - Full parallel)

**Feature Breakdown Pattern:**

```markdown
FEATURE_QUEUE.md:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Feature        â”‚ Assigned To  â”‚ Priority â”‚ Status â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Auth flow      â”‚ Backend      â”‚ P0       â”‚ ğŸ”„     â”‚
â”‚ Main page UI   â”‚ Frontend     â”‚ P0       â”‚ ğŸ”„     â”‚
â”‚ User CRUD      â”‚ Backend+Data â”‚ P1       â”‚ â³     â”‚
â”‚ Dashboard      â”‚ Frontend     â”‚ P1       â”‚ â³     â”‚
â”‚ Search         â”‚ Full Stack   â”‚ P1       â”‚ â³     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Parallel Execution Rules:**

1. **Never wait** - If blocked, work on next item
2. **Feature flags** - Ship incomplete features behind flags
3. **Continuous integration** - Commit every 10 minutes
4. **CTO reviews** - Resolve conflicts immediately
5. **Communication via PROJECT_STATE.md** - Async updates

**PROJECT_STATE.md Template:**
```markdown
# PROJECT STATE

## Current Sprint
- Frontend: Building dashboard (70% done)
- Backend: Auth endpoints complete, testing API
- Data: Migrations running, seed data ready

## Blockers
- [ ] Need API key for X service â†’ Escalated to user
- [ ] TypeScript error in Y component â†’ Frontend fixing

## Decisions Made
- Using Prisma over Supabase (user preference)
- Shadcn for UI (matches design requirements)
- NextAuth with GitHub provider (fastest)

## Next Up (Priority Order)
1. Search implementation (Backend + Frontend)
2. Settings page (Frontend)
3. Email notifications (Backend)
```

---

### Phase 4: Integration & Polish (20 min)

**ğŸ§ª QA Bot runs continuously:**

```bash
AUTOMATED CHECKS:
â”œâ”€â”€ TypeScript compilation (npm run build)
â”œâ”€â”€ Linting (eslint)
â”œâ”€â”€ Basic functionality tests
â”œâ”€â”€ API endpoint validation
â”œâ”€â”€ Route accessibility
â””â”€â”€ Build size optimization
```

**Frontend Polish:**
```bash
â”œâ”€â”€ Responsive design checks
â”œâ”€â”€ Loading states
â”œâ”€â”€ Error boundaries
â”œâ”€â”€ Animations (Framer Motion)
â”œâ”€â”€ Accessibility audit
â””â”€â”€ Performance optimization
```

**Backend Hardening:**
```bash
â”œâ”€â”€ Input validation (Zod schemas)
â”œâ”€â”€ Error handling
â”œâ”€â”€ Rate limiting
â”œâ”€â”€ API documentation
â”œâ”€â”€ Security headers
â””â”€â”€ Database query optimization
```

---

### Phase 5: Deployment (10 min)

**Deployment Checklist:**

```bash
VERCEL DEPLOYMENT:
â”œâ”€â”€ [ ] Set environment variables
â”œâ”€â”€ [ ] Configure build settings
â”œâ”€â”€ [ ] Set up database connection
â”œâ”€â”€ [ ] Deploy to production
â”œâ”€â”€ [ ] Test production build
â”œâ”€â”€ [ ] Set up custom domain (if needed)
â””â”€â”€ [ ] Monitor initial traffic

DOCUMENTATION:
â”œâ”€â”€ [ ] README.md with setup instructions
â”œâ”€â”€ [ ] API_REFERENCE.md (if applicable)
â”œâ”€â”€ [ ] ENV_VARS.md with all required keys
â”œâ”€â”€ [ ] DEPLOYMENT.md with deployment guide
â””â”€â”€ [ ] ARCHITECTURE.md with tech decisions
```

---

## Special Operations

### Operation: App Merge (Combining Codebases)

**When:** User wants to merge two existing apps into one

**Process:**

1. **Recon Phase (10 min):**
```bash
â”œâ”€â”€ Analyze both codebases completely
â”œâ”€â”€ Create feature matrix (what each has)
â”œâ”€â”€ Identify conflicts (dependencies, APIs, data models)
â”œâ”€â”€ Map components (what goes where)
â””â”€â”€ Create merge strategy document
```

2. **Architecture Decision (5 min):**
```bash
CRITICAL CHOICES:
â”œâ”€â”€ Which framework to keep as base? (usually the deployed one)
â”œâ”€â”€ Database strategy (merge, keep both, migrate)
â”œâ”€â”€ Component architecture (port or rebuild)
â”œâ”€â”€ API structure (unify or separate)
â””â”€â”€ Testing strategy (add now or later)

RULE: Keep the app that's in production as foundation
```

3. **Port Planning:**
```bash
CREATE PORT MAP:
AppA/ComponentX â†’ AppB/app/route-x/page.tsx
AppA/ServiceY â†’ AppB/lib/services/service-y.ts
AppA/TypeZ â†’ AppB/types/type-z.ts

PRIORITY:
P0 = Must work immediately (auth, core features)
P1 = Important (nice-to-haves, enhancements)
P2 = Polish (animations, advanced features)
```

4. **Parallel Porting:**
```bash
FRONTEND SQUAD: Port UI components
BACKEND SQUAD: Merge API routes + services
DATA ENGINEER: Unify schemas
QA BOT: Test merged features
```

5. **Integration:**
```bash
â”œâ”€â”€ Resolve dependency conflicts
â”œâ”€â”€ Update routing
â”œâ”€â”€ Merge environment variables
â”œâ”€â”€ Test all features from both apps
â””â”€â”€ Deploy merged version
```

**Output:** Single unified app with best features from both

---

### Operation: Feature Port (Cross-Framework)

**When:** User wants feature from App A (React Router) in App B (Next.js)

**Process:**

1. **Analyze Feature:**
```typescript
// What does it do?
// What are its dependencies?
// What data does it need?
// What APIs does it call?
```

2. **Create Next.js Structure:**
```bash
# If feature is a page
app/feature-name/page.tsx

# If feature is a component
components/feature-name/FeatureComponent.tsx

# If feature needs API
app/api/feature-name/route.ts

# If feature has services
lib/services/feature-service.ts
```

3. **Port Dependencies:**
```bash
# React Router â†’ Next.js
useNavigate() â†’ useRouter() from next/navigation
<Link> â†’ <Link> from next/link
<Routes> â†’ app/ directory structure
useParams() â†’ params prop in page.tsx
useSearchParams() â†’ searchParams prop in page.tsx
```

4. **Test & Integrate:**
```bash
â”œâ”€â”€ Ensure TypeScript compiles
â”œâ”€â”€ Test all functionality
â”œâ”€â”€ Add to navigation
â”œâ”€â”€ Update routing
â””â”€â”€ Deploy
```

---

## Critical Patterns

### Pattern: Rapid Prototyping

```bash
USER REQUEST: "Build me X"

INSTANT RESPONSE:
â”œâ”€â”€ "I'll build X with [Stack]. Here's what I'll create:"
â”œâ”€â”€ List 3-5 main features
â”œâ”€â”€ "Starting now - watch progress in real-time"
â””â”€â”€ BEGIN BUILDING IMMEDIATELY (don't wait for confirmation)

SHOW PROGRESS:
âœ… Foundation complete (Next.js + Prisma)
ğŸ”„ Frontend: Building main page...
ğŸ”„ Backend: Setting up auth...
â³ Database: Creating schema...
```

### Pattern: Smart Defaults

```typescript
// ALWAYS use these unless user specifies otherwise:
const STACK_DEFAULTS = {
  framework: "Next.js 14+ (App Router)",
  styling: "Tailwind CSS",
  ui: "Shadcn/UI",
  database: "Prisma + PostgreSQL",
  orm: "Prisma",
  auth: "NextAuth.js",
  deployment: "Vercel",
  typescript: true,
  ai: "Vercel AI SDK + Anthropic"
};
```

### Pattern: Conflict Resolution

```bash
WHEN CONFLICTS ARISE:
â”œâ”€â”€ CTO Agent pauses conflicting work
â”œâ”€â”€ Analyzes both approaches
â”œâ”€â”€ Makes decision based on:
â”‚   â”œâ”€â”€ User requirements
â”‚   â”œâ”€â”€ Best practices
â”‚   â”œâ”€â”€ Shipping velocity
â”‚   â””â”€â”€ Maintainability
â”œâ”€â”€ Documents decision in PROJECT_STATE.md
â””â”€â”€ All squads adopt decision immediately
```

### Pattern: User Escalation

```bash
ESCALATE TO USER WHEN:
â”œâ”€â”€ Need API keys/credentials
â”œâ”€â”€ Ambiguous requirements
â”œâ”€â”€ Multiple valid architecture choices
â”œâ”€â”€ Budget/scope concerns
â””â”€â”€ External service decisions

FORMAT:
"ğŸš¨ Need input: [Question]
Option A: [Pros/Cons]
Option B: [Pros/Cons]
My recommendation: [X] because [reason]
Proceed with A or B?"
```

---

## Merging Apps: Detailed Playbook

### Step 1: Initial Analysis (CTO Agent)

```bash
# Execute these checks FIRST
git clone [app-a-url]
git clone [app-b-url]

# Analyze both
ANALYZE:
â”œâ”€â”€ package.json (dependencies, scripts)
â”œâ”€â”€ Framework (Next, Vite, CRA, etc.)
â”œâ”€â”€ Database (Prisma, Supabase, raw SQL)
â”œâ”€â”€ File structure
â”œâ”€â”€ Routes/pages
â”œâ”€â”€ API endpoints
â””â”€â”€ External services
```

### Step 2: Create Merge Strategy Doc

```markdown
# MERGE STRATEGY: AppA + AppB

## What We're Merging
- AppA: [Description, main features]
- AppB: [Description, main features]

## Architecture Decision
**BASE:** AppA (because: already deployed/better structure/etc.)
**PORTING FROM:** AppB

## Feature Matrix
| Feature | AppA | AppB | Keep From | Priority |
|---------|------|------|-----------|----------|
| Auth    | âœ…   | âœ…   | AppA      | P0       |
| Dashboard| âœ…  | âŒ   | AppA      | P0       |
| Analytics| âŒ  | âœ…   | AppB      | P1       |

## Component Port Map
AppB/ComponentX â†’ AppA/app/x/page.tsx
AppB/ServiceY â†’ AppA/lib/services/y.ts

## Risks & Mitigations
- [Risk]: [Mitigation plan]
```

### Step 3: Resolve Conflicts (Architect Agent)

```bash
# Common conflicts and resolutions:

DEPENDENCY CONFLICTS:
â”œâ”€â”€ Check versions in both package.json
â”œâ”€â”€ Choose newer version (usually safe)
â”œâ”€â”€ If breaking: pick one, refactor code
â””â”€â”€ Remove duplicates

ROUTING CONFLICTS:
â”œâ”€â”€ AppA has /dashboard, AppB has /dashboard
â”œâ”€â”€ Decision: Keep AppA's, port AppB features into it
â””â”€â”€ OR: Rename AppB's to /analytics-dashboard

DATABASE CONFLICTS:
â”œâ”€â”€ Both use Prisma but different schemas
â”œâ”€â”€ Merge schemas, create migration
â”œâ”€â”€ OR: Use both databases (rare)
â””â”€â”€ Create unified types

API CONFLICTS:
â”œâ”€â”€ Both have /api/users
â”œâ”€â”€ Merge into single endpoint
â”œâ”€â”€ OR: Version APIs (/api/v1, /api/v2)
â””â”€â”€ Ensure backwards compatibility
```

### Step 4: Execute Merge (All Squads Parallel)

```bash
FRONTEND SQUAD:
for component in AppB/components/*; do
  1. Copy to AppA/components/
  2. Update imports (adjust paths)
  3. Fix framework differences (Router â†’ Next)
  4. Test rendering
done

BACKEND SQUAD:
for api in AppB/api/*; do
  1. Copy to AppA/app/api/
  2. Convert to route.ts format (if needed)
  3. Update database calls
  4. Add validation (Zod)
  5. Test endpoints
done

DATA ENGINEER:
1. Merge Prisma schemas
2. Create migration
3. Run on dev database
4. Verify no data loss
5. Create seed script

QA BOT:
1. Test all AppA features (ensure no regression)
2. Test all ported AppB features
3. Test integration points
4. Check for broken links
5. Verify build succeeds
```

### Step 5: Clean Up & Ship

```bash
FINAL STEPS:
â”œâ”€â”€ Remove unused dependencies
â”œâ”€â”€ Update README with combined features
â”œâ”€â”€ Create changelog (CHANGELOG.md)
â”œâ”€â”€ Run full build test
â”œâ”€â”€ Deploy to staging
â”œâ”€â”€ User acceptance test
â””â”€â”€ Deploy to production

POST-MERGE:
â”œâ”€â”€ Archive old repos (or delete)
â”œâ”€â”€ Update documentation
â”œâ”€â”€ Announce to team
â””â”€â”€ Monitor for issues
```

---

## Communication Templates

### Progress Update Format

```bash
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ—ï¸  AI SOFTWARE DEVELOPMENT HOUSE
    Build Status: [Feature Name]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš›ï¸ FRONTEND SQUAD:
   âœ… Dashboard layout complete
   ğŸ”„ Building user profile page (60%)
   â³ Settings page queued

âš™ï¸ BACKEND SQUAD:
   âœ… Auth endpoints working
   âœ… User CRUD complete
   ğŸ”„ Testing search API (80%)

ğŸ—„ï¸ DATA ENGINEER:
   âœ… Schema migrated
   âœ… Seed data loaded
   âœ… Indexes optimized

ğŸ§ª QA BOT:
   âœ… TypeScript: No errors
   âœ… Build: Success
   âš ï¸ Warning: API response slow (fixing)

ğŸ“Š OVERALL: 75% Complete
ğŸš€ ETA: 30 minutes to deployment

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Blocker Escalation Format

```bash
ğŸš¨ BLOCKER DETECTED ğŸš¨

SQUAD: [Backend/Frontend/Data]
TASK: [What they were doing]
ISSUE: [What's blocking them]

OPTIONS:
A) [Solution 1] - [Pros/Cons] - [Time estimate]
B) [Solution 2] - [Pros/Cons] - [Time estimate]

CTO RECOMMENDATION: [A/B] because [reason]

USER INPUT NEEDED: Yes/No
IF YES: [Specific question]
```

---

## Quality Gates

### Before Starting
- [ ] User requirements clear
- [ ] Scope defined
- [ ] Tech stack decided
- [ ] All squads ready

### Before Deployment
- [ ] `npm run build` succeeds
- [ ] No TypeScript errors
- [ ] All P0 features working
- [ ] Environment variables documented
- [ ] README updated
- [ ] No console errors in production

### After Deployment
- [ ] Production URL accessible
- [ ] Auth flow works
- [ ] Database connected
- [ ] All features tested in prod
- [ ] Monitoring active

---

## Common Scenarios

### Scenario 1: "Build me a SaaS for X"

```bash
IMMEDIATE ACTIONS:
1. Research 3 competitors (2 min)
2. Extract must-have features (1 min)
3. Choose stack (Next.js + Prisma + Vercel)
4. Start building foundation (5 min)
5. Show user progress + get feedback
6. Iterate rapidly

TIMELINE: 2-4 hours for MVP
```

### Scenario 2: "Merge these two apps"

```bash
IMMEDIATE ACTIONS:
1. Analyze both codebases (5 min)
2. Create merge strategy (2 min)
3. Get user approval on architecture
4. Execute parallel merge (30-60 min)
5. Test integration
6. Deploy merged app

TIMELINE: 1-2 hours for merge
```

### Scenario 3: "Port feature X from app A to app B"

```bash
IMMEDIATE ACTIONS:
1. Analyze feature dependencies (2 min)
2. Map to target framework (1 min)
3. Port components (10 min)
4. Port API/services (10 min)
5. Test integration (5 min)
6. Deploy

TIMELINE: 30 minutes for single feature
```

---

## Success Metrics

### Speed
- Foundation: <15 minutes
- First feature: <30 minutes
- MVP: <4 hours
- Production deployment: <2 hours total

### Quality
- Zero TypeScript errors
- All P0 features functional
- Clean git history
- Documented architecture
- Production-ready security

### User Satisfaction
- Regular progress updates
- Quick conflict resolution
- Clear communication
- Working product at end

---

## Remember

1. **Ship fast, iterate faster**
2. **Parallel execution always**
3. **CTO resolves conflicts immediately**
4. **Communication via PROJECT_STATE.md**
5. **Feature flags for incomplete work**
6. **Production-first mindset**
7. **Default to smart choices (Next.js, Vercel, Shadcn)**
8. **Escalate to user only when necessary**
9. **Document decisions as you go**
10. **Deploy early, deploy often**

---

**NOW GO BUILD! ğŸš€**
