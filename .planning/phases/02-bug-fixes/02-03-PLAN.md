---
phase: 02-bug-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - components/BehavioralBadges.tsx
  - components/OnboardingWrapper.tsx
  - components/ScoreExplainer.tsx
  - components/ui/toolbar-expandable.tsx
  - app/dashboard/page.tsx
autonomous: true

must_haves:
  truths:
    - "BehavioralBadges uses lazy initialization or proper effect patterns for cached data"
    - "OnboardingWrapper uses proper hydration gate pattern"
    - "ScoreExplainer does not setState synchronously in effect"
    - "toolbar-expandable uses proper state initialization"
    - "Dashboard page uses lazy initialization for plan/usage state"
    - "ESLint shows zero 'set-state-in-effect' errors for these files"
  artifacts:
    - path: "components/BehavioralBadges.tsx"
      provides: "Proper cache check pattern"
      pattern: "useState\\(\\(\\) =>"
    - path: "components/OnboardingWrapper.tsx"
      provides: "Hydration gate with eslint comment or lazy init"
      pattern: "(useState\\(\\(\\)|eslint-disable)"
    - path: "components/ScoreExplainer.tsx"
      provides: "No setState in effect"
      pattern: "useState\\(\\(\\) =>"
    - path: "components/ui/toolbar-expandable.tsx"
      provides: "Proper state initialization"
      pattern: "useState\\(\\(\\) =>"
    - path: "app/dashboard/page.tsx"
      provides: "Lazy initialization for pricing plan state"
      pattern: "useState\\(\\(\\) =>"
  key_links:
    - from: "components/BehavioralBadges.tsx"
      to: "sessionStorage cache"
      via: "lazy initializer or effect with async pattern"
      pattern: "(useState\\(\\(\\)|async.*setInsights)"
    - from: "app/dashboard/page.tsx"
      to: "getCurrentPlan/getUsageRecord"
      via: "lazy initializer"
      pattern: "useState\\(\\(\\) =>.*get"
---

<objective>
Fix remaining setState-in-useEffect anti-patterns in UI components and pages

Purpose: Complete the React hooks rule compliance for all critical components. These patterns cause unnecessary re-renders and can cause issues with React Strict Mode and concurrent features.

Output: Five files fixed with proper state initialization patterns
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-bug-fixes/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix BehavioralBadges setState in useEffect</name>
  <files>components/BehavioralBadges.tsx</files>
  <action>
Lines 72 and 278 have setState calls in useEffect for cache handling.

This is a data-fetching pattern where cache is checked in effect and setState is called. This is actually a legitimate async pattern, but ESLint flags it.

Read the file first. The pattern is likely:
```tsx
useEffect(() => {
  const cached = sessionStorage.getItem(cacheKey);
  if (cached) {
    const { data, timestamp } = JSON.parse(cached);
    if (Date.now() - timestamp < 5 * 60 * 1000) {
      setInsights(data);  // ESLint flags this
      setLoading(false);
      return;
    }
  }
  // fetch from API...
}, [username]);
```

Fix options:
1. Use lazy initializer for synchronous cache read (preferred):
```tsx
const [insights, setInsights] = useState<Insights | null>(() => {
  if (typeof window === 'undefined') return null;
  const cached = sessionStorage.getItem(cacheKey);
  if (cached) {
    try {
      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp < 5 * 60 * 1000) {
        return data;
      }
    } catch {}
  }
  return null;
});

const [loading, setLoading] = useState(() => {
  // If we have cached insights, don't show loading
  if (typeof window === 'undefined') return true;
  const cached = sessionStorage.getItem(cacheKey);
  if (cached) {
    try {
      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp < 5 * 60 * 1000) {
        return false;
      }
    } catch {}
  }
  return true;
});
```

2. Or add eslint-disable comment for the async fetch callback (less ideal but acceptable for async patterns):
```tsx
useEffect(() => {
  const fetchData = async () => {
    // ... fetch logic
    // eslint-disable-next-line react-hooks/set-state-in-effect -- Async data fetch
    setInsights(data);
  };
  fetchData();
}, []);
```

Prefer option 1 for the synchronous cache check portion.
  </action>
  <verify>Run `npm run lint 2>&1 | grep "BehavioralBadges.tsx"` - should show no "set-state-in-effect" errors (or have documented eslint-disable for async patterns)</verify>
  <done>BehavioralBadges uses lazy initialization for cached state and proper async patterns for API fetches.</done>
</task>

<task type="auto">
  <name>Task 2: Fix OnboardingWrapper, ScoreExplainer, and toolbar-expandable</name>
  <files>
    components/OnboardingWrapper.tsx
    components/ScoreExplainer.tsx
    components/ui/toolbar-expandable.tsx
  </files>
  <action>
Three files with similar patterns:
- OnboardingWrapper.tsx:18 - setMounted pattern (hydration gate)
- ScoreExplainer.tsx:118 - setState in effect
- toolbar-expandable.tsx:104 - setState in effect

For each file:
1. Read to understand the pattern
2. Apply the appropriate fix:

**OnboardingWrapper (hydration gate):**
The `setMounted(true)` pattern is intentional for hydration. Add eslint-disable comment:
```tsx
useEffect(() => {
  // eslint-disable-next-line react-hooks/set-state-in-effect -- Hydration gate
  setMounted(true);
}, []);
```

**ScoreExplainer and toolbar-expandable:**
Convert to lazy initializers where possible. If the state depends on props that change, consider:
- Deriving state from props without useState
- Using useMemo for computed values
- Using lazy initializer with proper SSR check

Example fix:
```tsx
// Before
const [expanded, setExpanded] = useState(false);
useEffect(() => {
  setExpanded(initialExpanded);
}, [initialExpanded]);

// After - if initialExpanded is a prop
// Just use the prop directly, or:
const [expanded, setExpanded] = useState(initialExpanded);
// (useState only uses initial value on first render anyway)
```
  </action>
  <verify>Run `npm run lint 2>&1 | grep -E "(OnboardingWrapper|ScoreExplainer|toolbar-expandable)" | grep -c error` returns 0</verify>
  <done>All three components use proper state patterns. Hydration gates documented with eslint-disable comments.</done>
</task>

<task type="auto">
  <name>Task 3: Fix dashboard page setState in useEffect</name>
  <files>app/dashboard/page.tsx</files>
  <action>
Line 67 has `setPlan(getPricingPlan(currentPlanId))` and `setUsage(getUsageRecord())` in useEffect.

These are calling synchronous functions to get initial state from localStorage. Convert to lazy initializers:

Before:
```tsx
const [plan, setPlan] = useState<PricingPlan | null>(null);
const [usage, setUsage] = useState<UsageRecord | null>(null);

useEffect(() => {
  const currentPlanId = getCurrentPlan();
  setPlan(getPricingPlan(currentPlanId));
  setUsage(getUsageRecord());
  // ...
}, []);
```

After:
```tsx
const [plan, setPlan] = useState<PricingPlan | null>(() => {
  if (typeof window === 'undefined') return null;
  const currentPlanId = getCurrentPlan();
  return getPricingPlan(currentPlanId);
});

const [usage, setUsage] = useState<UsageRecord | null>(() => {
  if (typeof window === 'undefined') return null;
  return getUsageRecord();
});

// Remove the setState calls from the effect, keep other logic
useEffect(() => {
  // Load hire tracking from localStorage (if there's other logic)
  // ...
}, []);
```

Note: Keep any async operations or side effects in the useEffect, just move synchronous localStorage reads to lazy initializers.
  </action>
  <verify>Run `npm run lint 2>&1 | grep "dashboard/page.tsx"` - should show no "set-state-in-effect" errors</verify>
  <done>Dashboard page uses lazy initialization for plan and usage state. No synchronous setState in useEffect.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint 2>&1 | grep -E "(BehavioralBadges|OnboardingWrapper|ScoreExplainer|toolbar-expandable|dashboard)" | grep -c "set-state-in-effect"` returns 0
2. `npm run type-check` passes
3. `npm run build` succeeds
</verification>

<success_criteria>
- BehavioralBadges.tsx: Lazy initialization for cache, async patterns documented
- OnboardingWrapper.tsx: Hydration gate documented with eslint-disable
- ScoreExplainer.tsx: Proper state initialization
- toolbar-expandable.tsx: Proper state initialization
- dashboard/page.tsx: Lazy initialization for plan/usage state
- All five files pass ESLint without set-state-in-effect errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-bug-fixes/02-03-SUMMARY.md`
</output>
