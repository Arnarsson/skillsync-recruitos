---
phase: 02-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/adminContext.tsx
  - lib/i18n/LanguageContext.tsx
  - hooks/usePersistedState.ts
  - components/ui/text-scramble.tsx
autonomous: true

must_haves:
  truths:
    - "Context providers use lazy state initialization, not setState in useEffect"
    - "usePersistedState does not access ref during render"
    - "text-scramble uses proper state initialization pattern"
    - "ESLint shows zero 'set-state-in-effect' errors for these files"
    - "ESLint shows zero 'Cannot access refs during render' errors"
  artifacts:
    - path: "lib/adminContext.tsx"
      provides: "Proper hydration pattern for admin state"
      pattern: "useState\\(\\(\\) =>"
    - path: "lib/i18n/LanguageContext.tsx"
      provides: "Lazy initialization for language from localStorage"
      pattern: "useState\\(\\(\\) =>"
    - path: "hooks/usePersistedState.ts"
      provides: "Ref access only in effects/callbacks, not during render"
      pattern: "useEffect.*lastSerializedRef"
    - path: "components/ui/text-scramble.tsx"
      provides: "Proper state initialization"
      pattern: "useState\\(\\(\\) =>"
  key_links:
    - from: "lib/adminContext.tsx"
      to: "localStorage"
      via: "lazy initializer function in useState"
      pattern: "useState\\(\\(\\) =>.*localStorage"
    - from: "lib/i18n/LanguageContext.tsx"
      to: "localStorage"
      via: "lazy initializer function in useState"
      pattern: "useState\\(\\(\\) =>.*localStorage"
---

<objective>
Fix state initialization patterns in context providers and hooks

Purpose: Eliminate setState-in-useEffect anti-patterns that cause cascading renders and potential hydration mismatches. Fix ref access during render which breaks React concurrent features.

Output: Four files fixed with proper lazy state initialization and effect-safe ref access
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-bug-fixes/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix adminContext setState in useEffect</name>
  <files>lib/adminContext.tsx</files>
  <action>
Line 21 has `setMounted(true)` in useEffect, which is flagged but is actually a legitimate hydration pattern. However, the ESLint rule is strict.

Read the file first to understand the pattern. Common fix approaches:

1. If the pattern is:
```tsx
const [mounted, setMounted] = useState(false);
const [isAdmin, setIsAdmin] = useState(false);

useEffect(() => {
  setMounted(true);
  const stored = localStorage.getItem('recruitos_admin_mode');
  if (stored) setIsAdmin(stored === 'true');
}, []);
```

Fix to:
```tsx
const [mounted, setMounted] = useState(false);
const [isAdmin, setIsAdmin] = useState(() => {
  if (typeof window === 'undefined') return false;
  return localStorage.getItem('recruitos_admin_mode') === 'true';
});

useEffect(() => {
  setMounted(true);
}, []);
```

The `setMounted(true)` in useEffect is acceptable for hydration gating - it's a known pattern. If ESLint still complains, add eslint-disable comment with explanation:
```tsx
useEffect(() => {
  // eslint-disable-next-line react-hooks/set-state-in-effect -- Intentional hydration gate
  setMounted(true);
}, []);
```

But first try to use lazy initializer for the actual state that reads from localStorage.
  </action>
  <verify>Run `npm run lint 2>&1 | grep "adminContext.tsx"` - should show no errors (or only acceptable warnings)</verify>
  <done>adminContext uses lazy state initialization for localStorage reads. Hydration gate pattern documented if eslint-disable needed.</done>
</task>

<task type="auto">
  <name>Task 2: Fix LanguageContext setState in useEffect</name>
  <files>lib/i18n/LanguageContext.tsx</files>
  <action>
Line 58 has setState in useEffect for language initialization.

Similar fix pattern as adminContext:

1. Read the file to understand current pattern
2. Move localStorage read to lazy useState initializer:

Before:
```tsx
const [language, setLanguage] = useState<Language>('en');

useEffect(() => {
  const stored = localStorage.getItem('recruitos_lang');
  if (stored && (stored === 'en' || stored === 'da')) {
    setLanguage(stored);
  }
}, []);
```

After:
```tsx
const [language, setLanguage] = useState<Language>(() => {
  if (typeof window === 'undefined') return 'en';
  const stored = localStorage.getItem('recruitos_lang');
  return (stored === 'en' || stored === 'da') ? stored : 'en';
});
```

This eliminates the extra render caused by setState in effect.
  </action>
  <verify>Run `npm run lint 2>&1 | grep "LanguageContext.tsx"` - should show no "set-state-in-effect" errors</verify>
  <done>LanguageContext uses lazy state initialization for language preference. No setState in useEffect for initial state.</done>
</task>

<task type="auto">
  <name>Task 3: Fix usePersistedState ref access during render</name>
  <files>hooks/usePersistedState.ts</files>
  <action>
Line 8 accesses `lastSerializedRef.current` during render (likely in useState initializer or outside effects).

The error "Cannot access refs during render" means the ref is being read synchronously during component render, not in an effect or callback.

Read the file and fix:

Before (BAD):
```tsx
const lastSerializedRef = useRef<string | null>(null);
const [state, setState] = useState(() => {
  const serialized = lastSerializedRef.current; // BAD: ref access during render
  // ...
});
```

After (GOOD):
```tsx
const lastSerializedRef = useRef<string | null>(null);
const [state, setState] = useState(() => {
  // Don't access ref here, just read from localStorage directly
  if (typeof window === 'undefined') return defaultValue;
  const stored = localStorage.getItem(key);
  return stored ? deserialize(stored) : defaultValue;
});

// Track last serialized value in effect, not during render
useEffect(() => {
  lastSerializedRef.current = serialize(state);
}, [state]);
```

The ref should only be accessed in:
- useEffect callbacks
- Event handlers
- Other callbacks (not during render)
  </action>
  <verify>Run `npm run lint 2>&1 | grep "usePersistedState.ts"` - should show no "Cannot access refs during render" errors</verify>
  <done>usePersistedState accesses refs only in effects and callbacks, never during render phase.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint 2>&1 | grep -E "(adminContext|LanguageContext|usePersistedState|text-scramble)" | grep -c "set-state-in-effect\|Cannot access"` returns 0
2. `npm run type-check` passes
3. App still works: contexts provide correct initial values from localStorage
</verification>

<success_criteria>
- adminContext.tsx: Lazy initialization for admin state, proper hydration gate
- LanguageContext.tsx: Lazy initialization for language preference
- usePersistedState.ts: Ref access only in effects, not during render
- text-scramble.tsx: Proper state initialization pattern
- All four files pass ESLint without set-state-in-effect or ref-access errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-bug-fixes/02-02-SUMMARY.md`
</output>
